\documentclass[Crown, sagev]{sagej}

\usepackage{amssymb, amsmath, amsfonts}


\include{GrandMacros}
\newcommand{\cdf}{{c.d.f.} }
\newcommand{\pdf}{{p.d.f.} }
\newcommand{\ind}{\mathbb{I}}

\begin{document}

\title{Infectious disease prediction with kernel conditional density
estimation}

\author{Evan L. Ray\affilnum{1},
Krzysztof Sakrejda\affilnum{1},
Stephen A. Lauer\affilnum{1},
Michael Johansen\affilnum{2} and
Nicholas G. Reich\affilnum{1}}

\affiliation{\affilnum{1}Department of Biostatistics and Epidemiology,
University of Massachusetts, Amherst\\
\affilnum{2}CDC, Puerto Rico}

\corrauth{Evan Ray, UMass Address Here}

\email{elray@umass.edu}

\begin{abstract}
Abstract
\end{abstract}
\keywords{Keywords, Keywords}

\maketitle

<<knitrGlobalSetup, echo = FALSE>>=
#opts_chunk$set(cache = TRUE, autodep = TRUE)
opts_chunk$set(cache = FALSE)
@

\section{Introduction}
\label{sec:Intro}

Accurate prediction of infectious disease incidence is important for public
health officials planning disease prevention and control measures such as vector
control and assignments of medical personnel.  Predictive distributions
are preferred to point predictions because they communicate uncertainty in the
predictions and give decision makers more information in cases where the
predictive distribution is skewed or has multiple modes.  In this work, we
employ a non-parametric approach referred to as kernel conditional density
estimation (KCDE) to obtain predictive distributions of disease incidence.  When
predictions for the trajectory of disease incidence over multiple time horizons
are required, our strategy is to use KCDE to obtain marginal predictive
distributions for each of those horizons and then combine them using copulas to obtain a joint predictive distribution.  In addition to the novel application of these methods to
predicting disease incidence, our contributions include a new kernel function
that handles both continuous and discrete count data while allowing for a fully
parameterized bandwidth matrix and the use of a periodic kernel specification to
capture seasonality in disease incidence.

KCDE is a method for estimating the conditional distribution of
a random vector $\bY$ given observations of another vector $\bX$.  In our work,
$\bY$ is a measure of disease incidence at some future date or dates (the prediction
target) and $\bX$ is a vector of predictive variables that we condition
on in order to make our prediction.  For example, $\bX$ may include
observations of incidence over the most recent few time
points, weather covariates, or variables indicating the time of year at which we are
making a prediction.  KCDE has not previously been applied to obtain predictive
distributions in the context of infectious disease, but it has been successfully
used for prediction in other settings such as survival time of lung cancer
patients\cite{hall2004crossvalidationKCDE}, female labor force participation\cite{hall2004crossvalidationKCDE}, bond yields and value at risk in financial
markets\cite{fan2004crossvalidationKCDE}, and wind
power\cite{jeon2012KCDEWindPower} among others.

Although KCDE has not previously been applied to predicting infectious disease,
closely related methods for obtaining point predictions have been employed for
diseases such as measles\cite{sugihara1990nonlinearForecasting} and
influenza\cite{viboud2003predictionInfluenzaMoA}.  In the infectious disease
literature these methods have been referred to as state space reconstruction and
the method of analogues, but they amount to an application of nearest neighbors
regression methods.  The point prediction obtained from nearest neighbors
regression is equal to the expected value of the predictive distribution
obtained from KCDE if a particular kernel function is used in the formulation of
KCDE\cite{HastieTibshiraniESL}.  However, KCDE offers the advantage of providing
a complete predictive distribution rather than only a point prediction.  There
is also a long history of using other modeling approaches, such as compartmental
models, for infectious disease prediction.  A full discussion of those methods
is beyond the scope of this article; see *** for a recent review.

\lboxit{Double check citation for sugihara -- right paper??}

\lboxit{Need to find a review of prediction methods for infectious disease.}

There is an extensive literature on KCDE, focusing mainly on estimation of
continuous conditional densities.  Here we offer a brief overview emphasizing
the case with mixed continuous and discrete variables; Li and
Racine\cite{li2007nonparametricEconometrics} offer a detailed discussion of this
case.  Throughout this article we use the term density to refer to the
Radon-Nikodym derivative of the cumulative distribution function with respect to an
appropriately defined measure.  In the case of random vectors where some
components are continuous random variables and other are discrete, we take this
measure to be a product of Lebesgue and counting measures for the corresponding
random variables.  We use bold letters to indicate column vectors; capital
letters are random variables and lower case letters are observations of those
random variables.

Given observations $\{(\bx_t, \by_t), t = 1, \ldots, T\}$,
KCDE estimates the conditional density of $\bY | \bX$ by
\begin{equation}
\widehat{f}_{\bY|\bX}(\by | \bx) = \frac{\sum_{t \in \btau} K^{\bX, \bY}\left\{(\bx', \by')', (\bx'_t, \by'_t)'; \bH^{\bX,\bY}\right\}}{\sum_{t \in \btau}K^{\bX}(\bx, \bx_t ; \bH^{\bX})}. \label{eqn:KCDEDefinition}
\end{equation}
Here, $'$ is the transpose operator and $\btau \subseteq \{1, \ldots, T\}$ indexes the subset of observations used
in obtaining the conditional density estimate.  In the final density estimate,
$\btau$ is typically equal to $\{1, \ldots, T\}$, but proper subsets may be
used in the estimation procedures we discuss later.  In
Equation~\eqref{eqn:KCDEDefinition}, the numerator is a kernel density estimate
of the joint density of $\bX$ and $\bY$ and the denominator is a kernel density
estimate of the marginal density of $\bX$; forming the quotient yields an
estimate of the conditional density of $\bY | \bX$.

We will work with a slightly restricted specification of
Equation~\eqref{eqn:KCDEDefinition} in which the kernel function $K^{\bX,\bY}$
can be written as the product of $K^{\bX}$ and a
``conditional kernel'' $K^{\bY|\bX}$:
\begin{equation}
K^{\bX,\bY}\left\{(\bx', \by')', (\bx'_t, \by'_t)'; \bH^{\bX,\bY}\right\} = K^{\bX}\left\{\bx, \bx_t; \bH^{\bX}\right\} K^{\bY | \bX}\left\{\by, \by_t | \bx, \bx_t; \bH^{\bX,\bY}\right\}.
\end{equation}
With this restriction, we can rearrange Equation~\eqref{eqn:KCDEDefinition} to
obtain
\begin{align}
\widehat{f}_{\bY|\bX}(\by | \bx) &= \sum_{t \in \btau} w_t K^{\bY | \bX}\left\{\by, \by_t | \bx, \bx_t; \bH^{\bX,\bY}\right\}, \text{ where} \label{eqn:KCDEDefinitionWeighted} \\
w_t &= \frac{K^{\bX}\left\{\bx, \bx_t; \bH^{\bX}\right\}}{\sum_{t^* \in \btau} K^{\bX}\left\{\bx, \bx_{t^*}; \bH^{\bX}\right\}}.
\end{align}

We can now interpret $K^{\bX}$ as a weighting function determining how much each
observation contributes to our final density estimate according to how similar
$\bx_t$ is to the value $\bx$ that we are conditioning on.
$K^{\bY | \bX}$ is a density function that contributes
mass to the final density estimate near the observed value $\by_t$; we require
that for any values of $\by_t$, $\bx_t$, and $\bx$, the integral of $K^{\bY |
\bX}$ with respect to $\by$ must equal $1$.
The bandwidth parameters $\bH^{\bX}$ and $\bH^{\bX, \bY}$ control the locality
and orientation of the weighting function and the contributions to the density
estimate from each observation.

In order to complete the formulation of the estimator given in
Equation~\eqref{eqn:KCDEDefinition}, we must specify the kernel functions and
describe the procedure that is used to estimate the bandwidth parameters.  To
our knowledge, all previous authors using kernel methods to estimate either
conditional or marginal densities with one or more discrete variables have
employed a kernel function that is a
product of univariate kernel functions
[\cite{aitchison1976multivariateBinaryKernel},
\cite{wang1981SmoothEstDiscreteDistn},
\cite{li2003nonparametricEstDistnsCategoricalContinuous},
\cite{ouyang2006crossvalidationEstDistnCategorical},
].
For the continuous variables, there are several options for the functional form;
one common choice is the Gaussian kernel.  Several alternatives have also been
proposed for use with discrete variables.  For ordered discrete variables,
symmetric univariate kernel functions that decrease with the distance between
$x$ and $x_t$ are often used; several specific functional forms that achieve
this have been used in the literature \cite{aitchison1976multivariateBinaryKernel,
wang1981SmoothEstDiscreteDistn,
li2008nonparametricConditionalCDFQuantile,
li2003nonparametricEstDistnsCategoricalContinuous,
ouyang2006crossvalidationEstDistnCategorical}.  For count data, alternatives
that have been proposed include.

%\cite{wang1981SmoothEstDiscreteDistn},
%\cite{li2008nonparametricConditionalCDFQuantile}\cite{li2003nonparametricEstDistnsCategoricalContinuous},
% \cite{ouyang2006crossvalidationEstDistnCategorical}].


Using a product kernel simplifies the mathemetical formulation of the kernel
function when both continuous and discrete variables are present, but has the
effect of forcing the kernel function to be orientied in line with the
coordinate axes.  In settings with only continuous variables, it is common to
use a multivariate kernel function with a bandwidth parameterization that allows
for orientations in directions other than along the coordinate axes.  Asymptotic
analysis and experience with applications have shown that this can result in
improved density estimates in many cases (cite ***).  One possibility for
introducing orientation to the kernel function is to use a fully parameterized
bandwidth matrix, allowing the kernel to be oriented in any direction.  Another
common alternative is to fix the orientation to be in the directions of the
eigenvectors of the sample covariance matrix.


Estimation.  Two main strategies:  cross validation and rule-based.  Targets for
optimization in cross-validation.  For
estimating joint densities without
conditioning, \cite{hart1990bandwidthEstDependentData} have shown that with
dependent data, but small gains in the mean integrated square error of the density estimate relative to the true conditional density can be achieved by leaving out observations adjacent to the time point whose density is being estimated.


A limitation of kernel-based density estimation methods is that they may not
scale well with the dimension of the vector whose distribution is being
estimated.  This is particularly relevant in our application, where it is
desired to obtain joint predictive distributions for disease incidence over the
course of many weeks.  Copulas present one strategy for estimating the joint
distribution of moderate to high dimensional random vectors, and work by
specifying a relatively simple parametric model for the dependence relations
among those variables.  Specifically, we model the joint distribution of $Y_1,
\ldots, Y_D$ by $F_{Y_1, \ldots, Y_D}(y_1, \ldots, y_D) = c(F_{Y_1}(y_1),
\ldots, F_{Y_D}(y_D) ; \btheta_c)$.  Here $c: [0,1]^D \rightarrow [0,1]$ is
the copula function depending on parameters $\btheta_c$ and mapping the vector
of marginal {c.d.f.} values to the joint {c.d.f.} value.

%We make several contributions in this article.  First, we apply KCDE to
%prediction of infectious disease (specifically, Dengue fever and Influenza), a
%novel application of the method which gives rise to several challenges and
%opportunities.  Among these challenges is the fact that infectious disease
%incidence can be quite noisy, with a lot of variation around a longer term
%trend; we will illustrate this in two real data sets in Section ***.  As we will
%see, this noise can cause difficulty for the method when applied to prediction
%of future incidence directly from recent observations of incidence.  Our
%solution is to introduce an initial low-pass filtering step on the observed
%incidence counts that are used as inputs to the predictions.

%Another challenge is in capturing seasonality in disease incidence.  In order
%to address this, we consider the use of periodic functions of the observation
%time as conditioning variables.  Effectively, this means that we can base our
%predictive density on previous observations that have been recorded at the time
%of year we are interested in.

%A third challenge is that for some applications, observations of disease
%incidence may take the form of discrete counts (i.e., the number of new cases
%in the last week).  If these incidence counts span a large range, it may be
%reasonable to approximate their predictive distribution with a continuous
%density function.  However, in our data for Dengue fever, the number of cases
%often falls within a limited range so that this continuous approximation is not
%reasonable.  We address this by discretizing an underlying continuous density
%function.  To our knowledge, this approach is novel in the KCDE literature.

The remainder of this article is organized as follows.  We:
 - describe how kernel density estimation with a non-diagonal bandwidth can be
 achieved using a partially discretized multivariate normal distribution for the
 kernel functions.

 - simulation study comparing product and non-product formulations for marginal
 and conditional density estimation
 
 - applications

\section{Method Description}
\label{sec:MethodDescription}

Suppose we observe $\bz_t = \{z_{t,1}, \ldots, z_{t,D}\} \in \mathbb{R}^D$ at
each point in time $t = 1, \ldots, T$.  Our goal is to obtain a predictive
distribution for one of the observed variables, with index $d_{pred} \in \{1,
\ldots, D\}$, over a range of prediction horizons contained in the set
$\mathcal{P}$.  For example, if we have weekly data and we are interested in
obtaining predictions for a range between 4 and 6 weeks after the most recent
observation then $\mathcal{P} = \{4, 5, 6\}$.  Let $P$ be the largest element of
the set $\mathcal{P}$ of prediction horizons.

For each time $t \in \btau$, we form the vectors $\by_t$ and $\bx_t$
representing the prediction target and predictive variables respectively.  

In order to perform prediction, we will use lagged observations.  Let $\bl^{max} = (l^{max}_1, \ldots, l^{max}_D)$ specify the maximum number of lags for each observed variable that may be used for prediction, and let $L = \max{d} l^{max}_d$ be the overall largest lag that may be used across all variables.  In the estimation procedure we describe in Section~\ref{sec:Estimation}, we will select a subset of these lags to actually use in the predictions.  We capture which lags are actually used in the vector 
\begin{align*}
&\bu = (u_{1,0}, \ldots, u_{1, l^{max}_1}, \ldots, u_{D,0}, \ldots, u_{D, l^{max}_D}) \text{, where} \\
&u_{d, l} = \begin{cases} 0 \text{ if lag $l$ of variable $d$ is not used in forming predictions} \\ 1 \text{ if lag $l$ of variable $d$ is used in forming predictions.} \end{cases}
\end{align*}

By analogy with the standard notation in autoregressive models, we define
\begin{align*}
&\by_t = (z_{t, d_{pred}}, \ldots, B^{(P - 1)} z_{t, d_{pred}}) \text{ and} \\
&\bx_t = (B^{(P)} z_{t, 1}, \ldots, B^{(P + l^{max}_1 - 1)} z_{t, 1}, \ldots, B^{(P)} z_{t, D}, \ldots, B^{(P + l^{max}_D - 1)} z_{t, D})
\end{align*}
Here, $B^{(a)}$ is the backshift operator defined by $B^{(a)} z_{t, d} = z_{t - a, d}$.  Note that the lengths of $\by_t$ and $\bx_t$, as well as exactly which lags are used to form them, depend on $\mathcal{P}$ and $\bl^{max}$; we suppress this dependence in the notation for the sake of clarity.  The vector $\by_t$ represents the prediction target when our most recent observation was made at time $t - P$: the vector of observed values at each prediction horizon $p \in \mathcal{P}$.  The variable $\bx_t$ represents the vector of all lagged covariates that are available for use in performing prediction.

To make the notation concrete, suppose that $\bz_t$ contains the observed case count for week $t$ in San Juan, the observed case count for week $t$ in Iquitos, and the date on Monday of week $t$, and our goal is to predict the weekly case count in San Juan.  Then $D = 3$ and $d_{pred} = 1$.  If we want to predict the weekly case counts for the two weeks after the most recently observation, then $p = 2$.  If we specify that the model may include the two most recent observations for the case counts in San Juan and Iquitos, but only the time index at the most recent observation then $\bl^{max} = (1, 1, 0)$.  If our current model uses only the most recently observed case counts for San Juan and Iquitos then $\bu = (1, 0, 1, 0, 0)$, where the 1's are in the positions of the $\bu$ vector representing lag 0 of the counts for San Juan and lag 0 of the counts for Iquitos.  The variable $y_t^{(P)}$ is a vector containing the observed case counts for San Juan in weeks $t + 1$ and $t + 2$; $\bx_t^{(\bl^{max})}$ contains the observed case counts for San Juan and Iquitos in weeks $t$ and $t - 1$ as well as the time index variable in week $t$.

In order to perform prediction, we regard $\{(\by_t, \bx_t), t = 1 + P + L, \ldots, T\}$ as a sample from the joint distribution of $(\bY, \bX)$.  We wish to estimate the conditional distribution of $\bY | \bX$.  In order to do this, we employ kernel density estimation.  Let $K^{\bY}(\by, \by^*, H^{\bY})$ and $K^{\bX}(\bx, \bx^*, H^{\bX})$ be kernel functions centered at $\by^*$ and $\bx^*$ respectively and with bandwidth matrices $H^{\bY}$ and $H^{\bX}$.  We estimate the conditional distribution of $\bY | \bX$ as follows:
\begin{align}
&\widehat{f}_{\bY|\bX}(\by | \bX = \bx) = \frac{\widehat{f}_{\bY, \bX}(\by, \bx)}{\widehat{f}_{\bX}(\bx)} \label{eqn:KDECondDef} \\
&\qquad = \frac{\sum_{t \in \tau} K^{\bY, \bX}\{(\by, \bx), (\by_t, \bx_t), H^{\bY, \bX}\}}{\sum_{t \in \tau} K^{\bX}(\bx, \bx_t, H^{\bX}) } \label{eqn:KDESubKDEJtMarginal} \\
&\qquad = \frac{\sum_{t \in \tau} K^{\bY | \bX}(\by, \by_t | \bx, \bx_t, H^{\bY, \bX}) K^{\bX}(\bx, \bx_t, H^{\bX})}{\sum_{t \in \tau} K^{\bX}(\bx, \bx_t, H^{\bX}) } \label{eqn:KDESubKDEJtMarginal} \\
&\qquad = \sum_{t \in \tau} w_t K^{\bY | \bX}(\by, \by_t | \bx, \bx_t, H^{\bY, \bX}) \text{, where} \label{eqn:KDEwt} \\
&w_t = \frac{ K^{\bX}(\bx, \bx_t, H^{\bX}) }{\sum_{t^* \in \tau} K^{\bX}(\bx, \bx_{t^*}, H^{\bX}) } \label{eqn:KDEWeightsDef}
\end{align}

In Equation~\eqref{eqn:KDECondDef}, we are making use of the fact that the conditional density for $\bY | \bX$ can be written as the quotient of the joint density for $(\bY, \bX)$ and the marginal density for $\bX$.  In Equation~\eqref{eqn:KDESubKDEJtMarginal}, we obtain separate kernel density estimates for the joint and marginal densities in this quotient.  In Equation~\eqref{eqn:KDEwt}, we rewrite this quotient by passing the denominator of Equation~\eqref{eqn:KDESubKDEJtMarginal} into the summation in the numerator.  We can interpret the result as a weighted kernel density estimate, where each observation $t \in \tau$ contributes a different amount to the final conditional density estimate.  The amount of the contribution from observation $t$ is given by the weight $w_t$, which effectively measures how similar $\bx_t$ is to the point $\bx$ at which we are estimating the conditional density.  If $\bx_t^{(\bl^{max})}$ is similar to $\bx_{t^*}^{(\bl^{max})}$, a large weight is assigned to $t$; if $\bx_t^{(\bl^{max})}$ is different from $\bx_{t^*}^{(\bl^{max})}$, a small weight is assigned to $t$.

In kernel density estimation, it is generally required that the kernel functions integrate to $1$ in order to obtain valid density estimates.  However, after conditioning on $\bX$, it is no longer necessary that $K^{\bX}(\bx, \bx_t, H^{\bX})$ integrate to $1$.  In fact, as can be seen from Equation~\eqref{eqn:KDEWeightsDef}, any multiplicative constants of proportionality will cancel out when we form the observation weights.  We can therefore regard $K^{\bX}(\bx, \bx_t, H^{\bX})$ as a more general weighting function that measures the similarity between $\bx$ and $\bx_t$.  As we will see, eliminating the constraint that $K^{\bX}$ integrates to $1$ is a useful expansion the space of functions that can be used in calculating the observation weights.  However, we still require that $K^{\bY}$ integrates to $1$.

In Equations \eqref{eqn:KDECondDef} through \eqref{eqn:KDEWeightsDef}, $\tau$ is an index set of time points used in obtaining the density estimate.  In most settings, we can take $\tau = \{1 + P + L, \ldots, T\}$.  These are the time points for which we can form the lagged observation vector $\bx_t$ and the prediction target vector $\by_t$.  However, we will place additional restrictions on the time points included in $\tau$ in the cross-validation procedure discussed in Section \ref{sec:Estimation}.

If we wish to obtain point predictions, we can use a summary of the predictive density.  For example, if we take the expected value, we obtain kernel regression:
\begin{align}
&(\widehat{\bY} | \bX = \bx) = \mathbb{E}_{\widehat{f}_{\bY|\bX}}\{\bY | \bX = \bx\} \label{eqn:PtPredDef} \\
&\qquad = \int \sum_{t \in \tau} w_t K^{\bY}(\by, \by_t, H^{\bY}) \by \, d \by  \label{eqn:PtPredKDE} \\
&\qquad = \sum_{t \in \tau} w_t \by_t  \label{eqn:PtPredFinal}
\end{align}
The equality in Equation~\eqref{eqn:PtPredFinal} holds if the kernel function $K^{\bY}(\by, \by_t, H^{\bY})$ is symmetric about $\by_t$, or more generally if it is the pdf of a random variable with expected value $\by_t$.


Another alternative that we pursue is the use of smoothed observations in forming the lagged observation vectors.  We use smoothed case counts on a log scale for the weighting kernels, and the unsmoothed case counts on the original scale for the prediction kernels.

\section{Parameter Estimation}
\label{sec:Estimation}

We use cross-validation to select the variables that are used in the model and estimate the corresponding bandwidth parameters by (approximately) minimizing a cross-validation measure of the quality of the predictions obtained from the model.  Formally,
\begin{align}
&(\widehat{\bu}, \widehat{H}^{\bX}, \widehat{H}^{\bY}) \approx \argmin{(\bu, H^{\bX}, H^{\bY})} \sum_{t^* = 1 + P + L}^T Q[ \by_{t^*}, \widehat{f}(\by | \bX = \bx_{t^*} ; \bu, H^{\bX}, H^{\bY}, \{ (\by_t, \bx_t): t \in \tau_{t^*} \}) ] \label{eqn:ParamEst}
\end{align}
Here, $Q$ is a loss function that measures the quality of the estimated density $\widehat{f}$ given an observation $\by_{t^*}$.  We have made the dependence of this estimated density on the the parameters $\bu$, $H^{\bx}$, and $H^{\bY}$, as well as on the data $\{ (\by_t, \bx_t): t \in \tau_{t^*} \}$, explicit in the notation.  In order to reduce the potential for our parameter estimates to be affected by local correlation in the time series, we eliminate all time points that fall within one year of $t^*$ from the index set $\tau_{t^*}$ used to form the conditional density estimate $\widehat{f}(\by | \bX = \bx_{t^*} ; \bu, H^{\bX}, H^{\bY}, \{ (\by_t, \bx_t): t \in \tau_{t^*} \})$.

\lboxit{Talk about proper scoring rules and our particular choice of $Q$.}

We use a forward/backward stagewise procedure to obtain the set of combinations of variables and lags that are included in the final model (represented by $\bu$).  For each candidate model, we use the limited memory box constrained optimization procedure of \cite{byrd1995limitedmemoryoptim} to estimate the bandwidth parameters.  The approximation in Equation~\eqref{eqn:ParamEst} is due to the fact that this optimization procedure may not find a global minimum.


\section{Simulation Studies}
\label{sec:SimStudies}

In this Section, we conduct two sets of simulation studies designed to answer
two separate questions:
\begin{enumerate}
\item How much does using a kernel function with a non-diagonal bandwidth matrix
contribute to the quality of conditional density estimates relative to density
estimates obtained through KCDE using diagonal bandwidth matrices?
\item How does our method perform in the context of seasonal time series data? 
Specifically, how does the method perform relative to common alternatives, and
how much do each of our three contributions (non-diagonal bandwidth matrices for
discrete data, using a periodic function of time as predictive variable, and
use of low band-pass filtered observatiosn as predictive variables) contribute
to predictive performance?
\end{enumerate}

\subsection{Comparison of KCDE approaches}
\label{sec:SimStudiesKCDEComparison}

Our first set of simulation studies is based closely on those conducted in
\cite{duong2005crossvalidationBandwidthMultivariateKDE}; their examples
demonstrate the utility of using a fully parameterized bandwidth matrix in
kernel density estimation of continuous distributions.  We modify their
simulation study to examine the benefits of fully parameterized bandwidth
matrices in the context of conditional density estimation with discrete
variables.

We simulate observations from each of seven distributions.  The first five of
these are plotted in Figure ***.


<<SimStudyDistributionsDiscretizedDuongHazelton>>=
library(ggplot2)
library(grid)
library(plyr)
library(dplyr)
library(tidyr)
library(pdtmvn)
library(kcde)
source("/media/evan/data/Reich/infectious-disease-prediction-with-kcde/inst/code/sim-densities-sim-study-discretized-Duong-Hazelton.R")

## Density family bivariate-A
n_sim <- 10000
discrete_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-A-discretized") %>%
    as.data.frame()
continuous_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-A") %>%
    as.data.frame()
discrete_sample_counts <- discrete_sample %>%
    count(X1, X2)

pa <- ggplot() +
    geom_density_2d(aes(x = X1, y = X2), data = continuous_sample) +
    geom_point(aes(x = X1, y = X2, colour = n), data = discrete_sample_counts)
pa

## Density family bivariate-B
n_sim <- 10000
discrete_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-B-discretized") %>%
    as.data.frame()
continuous_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-B") %>%
    as.data.frame()
discrete_sample_counts <- discrete_sample %>%
    count(X1, X2)

pb <- ggplot() +
    geom_density_2d(aes(x = X1, y = X2), data = continuous_sample) +
    geom_point(aes(x = X1, y = X2, colour = n), data = discrete_sample_counts)
pb

## Density family bivariate-C
n_sim <- 10000
discrete_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-C-discretized") %>%
    as.data.frame()
continuous_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-C") %>%
    as.data.frame()
discrete_sample_counts <- discrete_sample %>%
    count(X1, X2)

pc <- ggplot() +
    geom_density_2d(aes(x = X1, y = X2), data = continuous_sample) +
    geom_point(aes(x = X1, y = X2, colour = n), data = discrete_sample_counts)
pc

## Density family bivariate-D
n_sim <- 10000
discrete_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-D-discretized") %>%
    as.data.frame()
continuous_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "bivariate-D") %>%
    as.data.frame()
discrete_sample_counts <- discrete_sample %>%
    count(X1, X2)

pd <- ggplot() +
    geom_density_2d(aes(x = X1, y = X2), data = continuous_sample) +
    geom_point(aes(x = X1, y = X2, colour = n), data = discrete_sample_counts)
pd

## Density family multivariate-2d
n_sim <- 10000
discrete_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "multivariate-2d-discretized") %>%
    as.data.frame()
continuous_sample <- sim_from_pdtmvn_mixt(n = n_sim, sim_family = "multivariate-2d") %>%
    as.data.frame()
discrete_sample_counts <- discrete_sample %>%
    count(X1, X2)

pd <- ggplot() +
    geom_density_2d(aes(x = X1, y = X2), data = continuous_sample) +
    geom_point(aes(x = X1, y = X2, colour = n), data = discrete_sample_counts)
pd

@

\section{Examples}
\label{sec:Examples}

In this Section, we illustrate the methods through applications to prediction in
examples with several real time series data sets.

\subsection{Example 1: Influenza Prediction}

In our first and simplest example, we apply the method for prediction of
influenza with prediction horizons of 1 through 4 weeks.  Data on influenza
incidence are available through {\tt R}'s {\tt cdcfluview} package.  Here we
create a data set with a nationally aggregated measure of flu incidence

<<FluDataLoadData, echo = FALSE>>=
library(cdcfluview)
library(plyr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(grid)
library(kcde)

usflu<-get_flu_data("national", "ilinet", years=1997:2015)
ili_national <- transmute(usflu,
    region.type = REGION.TYPE,
    region = REGION,
    year = YEAR,
    week = WEEK,
    weighted_ili = as.numeric(X..WEIGHTED.ILI))
ili_national$time <- ymd(paste(ili_national$year, "01", "01", sep = "-"))
week(ili_national$time) <- ili_national$week
ili_national$time_index <- seq_len(nrow(ili_national))

str(ili_national)
@

We plot the {\tt total\_cases} measure over time, representing missing values
with vertical grey lines.  The low season was not measured in the first few
years.

<<FluDataInitialPlotTotalCases, echo = FALSE>>=
ggplot() +
    geom_line(aes(x = as.Date(time), y = weighted_ili), data =
ili_national) +
    geom_vline(aes(xintercept = as.numeric(as.Date(time))),
        colour = "grey",
        data = ili_national[is.na(ili_national$weighted_ili), ]) +
    scale_x_date() +
    xlab("Time") +
    ylab("Weighted ILI") +
    theme_bw()
@

There are several methods that we could employ to handle these missing data:
\begin{enumerate}
\item Impute the missing values.  They are all in the low season, so this should be relatively easy to do.
\item Drop all data up through the last NA.
\item Use the data that are available.
\end{enumerate}
Of these approaches, the first is probably preferred.  The concern with the second
is that we are not making use of all of the available data.  The potential concern with the
third is that in the data used in estimation, there will be more examples of prediction of values in the high season
using values in the high season and middle of the season than of prediction of values in the high season using values in the low season.
This could potentially affect our inference.  However, we do not expect this effect to be large,
so we proceed with this option for the purposes of this example.

We also plot histograms of the observed total cases on the original scale and on the log scale.

<<FluDataHistogramPlotTotalCases, echo = FALSE>>=
hist_df <- rbind(
	data.frame(value = ili_national$weighted_ili,
    	variable = "Weighted ILI"),
    data.frame(value = log(ili_national$weighted_ili),
    	variable = "log(Weighted ILI)")
)

ggplot(aes(x = value), data = hist_df) +
    geom_histogram() +
    facet_wrap( ~ variable, ncol = 2) +
    xlab("Weighted ILI") +
    theme_bw()
@

These plots demonstrate that total cases follows an approximately log-normal
distribution.  In the application below, we will consider modeling these data on
both the original scale and the log scale.  Intuitively, since we are using a
kernel that is obtained from a Gaussian, modeling the data on the log scale
should yield better performance.  On the other hand, the performance gain may be
negligible if we have enough data.

Finally, we plot the autocorrelation function:

<<FluDataACFPlotTotalCases, echo = FALSE>>=
last_na_ind <- max(which(is.na(ili_national$weighted_ili)))
non_na_inds <- seq(from = last_na_ind + 1, to=nrow(ili_national))
acf(ili_national$weighted_ili[non_na_inds],
  lag.max = 52 * 4)
@

This plot illustrates the annual periodicity that was also visible in the
initial data plot above.  There is no apparent evidence of longer term annual
cycles.  We therefore include a periodic kernel acting on the time index with a
period of 52.2 weeks (the length of the period is motivated by the fact that
in our data, there is a year with 53 weeks once every 5 or 6 years).

We now do some set up for estimation and prediction with kcde.  First, we 
create a list with parameters that specify the kernel function components.

%<<FluDataKernelComponentsSetup, echo = TRUE>>=
%## Definitions of kernel components.  A couple of notes:
%##   1) In the current implementation, it is required that separate kernel
%##      components be used for lagged (predictive) variables and for leading
%##      (prediction target) variables.
%##   2) The current syntax is verbose; in a future version of the package,
%##      convenience functions may be provided.
%
%## Define kernel components -- 3 pieces:
%##   1) Periodic kernel acting on time index
%##   2) pdtmvn kernel acting on lagged total cases (predictive) -- all continuous
%##   3) pdtmvn kernel acting on lead total cases (prediction target) -- all continuous
%kernel_components <- list(
%    list(
%        vars_and_offsets = data.frame(var_name = "time_index",
%            offset_value = 0L,
%            offset_type = "lag",
%            combined_name = "time_index_lag0",
%            stringsAsFactors = FALSE),
%        kernel_fn = periodic_kernel,
%        theta_fixed = list(period=pi / 52.2),
%        theta_est = list("bw"),
%        initialize_kernel_params_fn = initialize_params_periodic_kernel,
%        initialize_kernel_params_args = NULL,
%        vectorize_kernel_params_fn = vectorize_params_periodic_kernel,
%        vectorize_kernel_params_args = NULL,
%        update_theta_from_vectorized_theta_est_fn = update_theta_from_vectorized_theta_est_periodic_kernel,
%        update_theta_from_vectorized_theta_est_args = NULL
%    ),
%    list(
%        vars_and_offsets = data.frame(var_name = "weighted_ili",
%            offset_value = 1L,
%            offset_type = "horizon",
%            combined_name = "time_index_horizon1",
%            stringsAsFactors = FALSE),
%        kernel_fn = pdtmvn_kernel,
%        rkernel_fn = rpdtmvn_kernel,
%        theta_fixed = list(
%            parameterization = "bw-diagonalized-est-eigenvalues",
%            continuous_vars = "weighted_ili_horizon1",
%            discrete_vars = NULL,
%            discrete_var_range_fns = NULL,
%            lower = -Inf,
%            upper = Inf
%        ),
%        theta_est = list("bw"),
%        initialize_kernel_params_fn = initialize_params_pdtmvn_kernel,
%        initialize_kernel_params_args = NULL,
%        vectorize_kernel_params_fn = vectorize_params_pdtmvn_kernel,
%        vectorize_kernel_params_args = NULL,
%        update_theta_from_vectorized_theta_est_fn = update_theta_from_vectorized_theta_est_pdtmvn_kernel,
%        update_theta_from_vectorized_theta_est_args = NULL
%    ))#,
%    list(
%        vars_and_lags = vars_and_lags[3:5, ],
%        kernel_fn = pdtmvn_kernel,
%        rkernel_fn = rpdtmvn_kernel,
%        theta_fixed = NULL,
%        theta_est = list("bw"),
%        initialize_kernel_params_fn = initialize_params_pdtmvn_kernel,
%        initialize_kernel_params_args = list(
%            continuous_vars = vars_and_lags$combined_name[3:4],
%            discrete_vars = vars_and_lags$combined_name[5],
%            discrete_var_range_fns = list(
%                c_lag2 = list(a = pdtmvn::floor_x_minus_1, b = floor, in_range = pdtmvn::equals_integer, discretizer = round_up_.5))
%        ),
%        vectorize_theta_est_fn = vectorize_params_pdtmvn_kernel,
%        vectorize_theta_est_args = NULL,
%        update_theta_from_vectorized_theta_est_fn = update_theta_from_vectorized_theta_est_pdtmvn_kernel,
%        update_theta_from_vectorized_theta_est_args = list(
%            parameterization = "bw-diagonalized-est-eigenvalues"
%        )
%    ))
%@

<<FluDataMergePredictionResults, echo = FALSE>>=
library(plyr)
library(dplyr)
library(tidyr)

ili_prediction_results_sarima <- readRDS("/media/evan/data/Reich/infectious-disease-prediction-with-kcde/inst/results/ili_national/prediction-results/sarima-predictions.rds")
ili_prediction_results_kcde <- readRDS("/media/evan/data/Reich/infectious-disease-prediction-with-kcde/inst/results/ili_national/prediction-results/kcde-predictions.rds")
ili_prediction_results <- rbind.fill(ili_prediction_results_sarima[!is.na(ili_prediction_results_sarima$log_score), ],
    ili_prediction_results_kcde)
ili_prediction_results$AE <- unlist(ili_prediction_results$AE)

ili_prediction_results$full_model_descriptor <- paste0(ili_prediction_results$model,
    "-seasonal_lag_", ili_prediction_results$max_seasonal_lag,
#    "-filtering_", ili_prediction_results$filtering,
    "-differencing_", ili_prediction_results$differencing,
    "-periodic_", ili_prediction_results$seasonality,
    "-bw_", ili_prediction_results$bw_parameterization)
@

%<<FluDataRibbonsPredictionPlot50Intervals, echo = FALSE>>=
%ribbons_df <- ili_prediction_results %>%
%    select(prediction_time,
%        prediction_horizon,
%        full_model_descriptor,
%        model,
%        interval_pred_lb_95:interval_pred_ub_50) %>%
%    gather("bound_type", "predictive_value", interval_pred_lb_95:interval_pred_ub_50) %>%
%    mutate(interval_type = ifelse(grepl("50", bound_type), "50", "95"),
%        bound_type = ifelse(grepl("lb", bound_type), "lower", "upper")) %>%
%    spread(bound_type, predictive_value)
%
%phs_used <- c(1, 6, 13, 26, 52)
%models_used <- c("SARIMA-filtering_NA-periodic_NA-bw_NA", "kcde-filtering_FALSE-periodic_TRUE-bw_full")
%
%ggplot() +
%    geom_ribbon(aes(x = prediction_time, ymin = lower, ymax = upper, colour = model, fill = model),
%        alpha = 0.4,
%        size = 0,
%        data = ribbons_df[ribbons_df$prediction_horizon %in% phs_used &
%                ribbons_df$full_model_descriptor %in% models_used &
%                ribbons_df$interval_type == "50", ]) +
%    geom_line(aes(x = time, y = weighted_ili), data = ili_national[ili_national$year %in% 2010:2014, ]) +
%#    geom_point(aes(x = time, y = weighted_ili), data = ili_national[ili_national$year %in% 2010:2014, ]) +
%    geom_line(aes(x = prediction_time, y = pt_pred, colour = model),
%        data = ili_prediction_results[ili_prediction_results$prediction_horizon %in% phs_used &
%                ili_prediction_results$full_model_descriptor %in% models_used, ]) +
%#    scale_alpha_discrete("Prediction\nInterval\nCoverage",
%#        labels = c("50 Percent", "95 Percent"),
%#        limits = c("50", "95"),
%#        range = c(0.4, 0.2)) +
%    facet_wrap( ~ prediction_horizon, ncol = 1) +
%    ggtitle("Point and 50% Interval Predictions") +
%    theme_bw()
%@
%
%
%<<FluDataRibbonsPredictionPlot95Intervals, echo = FALSE>>=
%ggplot() +
%    geom_ribbon(aes(x = prediction_time, ymin = lower, ymax = upper, colour = model, fill = model),
%        alpha = 0.4,
%        size = 0,
%        data = ribbons_df[ribbons_df$prediction_horizon %in% phs_used &
%                ribbons_df$full_model_descriptor %in% models_used &
%                ribbons_df$interval_type == "95", ]) +
%    geom_line(aes(x = time, y = weighted_ili), data = ili_national[ili_national$year %in% 2010:2014, ]) +
%#    geom_point(aes(x = time, y = weighted_ili), data = ili_national[ili_national$year %in% 2010:2014, ]) +
%    geom_line(aes(x = prediction_time, y = pt_pred, colour = model),
%        data = ili_prediction_results[ili_prediction_results$prediction_horizon %in% phs_used &
%                ili_prediction_results$full_model_descriptor %in% models_used, ]) +
%#    scale_alpha_discrete("Prediction\nInterval\nCoverage",
%#        labels = c("50 Percent", "95 Percent"),
%#        limits = c("50", "95"),
%#        range = c(0.4, 0.2)) +
%    facet_wrap( ~ prediction_horizon, ncol = 1) +
%    ggtitle("Point and 95% Interval Predictions") +
%    theme_bw()
%@


%<<FluDataPredictionsPlotViolinLogScore>>=
%library(ggplot2)
%
%ggplot() +
%    geom_violin(aes(x = factor(full_model_descriptor), y = log_score), data =
%     ili_prediction_results) + theme_bw()
%@

<<FluDataPredictionsPlotViolinLogScoreDifference, fig.height = 8, echo = FALSE>>=
ili_prediction_log_score_diffs_wide <- ili_prediction_results %>%
    select(full_model_descriptor, prediction_time, prediction_horizon, log_score) %>%
    spread(full_model_descriptor, log_score)

ili_prediction_log_score_diffs_wide[, unique(ili_prediction_results$full_model_descriptor)] <-
    ili_prediction_log_score_diffs_wide[, unique(ili_prediction_results$full_model_descriptor)] -
    ili_prediction_log_score_diffs_wide[, "SARIMA-seasonal_lag_NA-differencing_NA-periodic_NA-bw_NA"]
#    ili_prediction_log_score_diffs_wide[, "SARIMA-seasonal_lag_NA-filtering_NA-differencing_NA-periodic_NA-bw_NA"]

ili_prediction_log_score_diffs_long <- ili_prediction_log_score_diffs_wide %>%
    gather_("model", "log_score_difference", unique(ili_prediction_results$full_model_descriptor))

ggplot() +
    geom_violin(aes(x = factor(model), y = log_score_difference), data = ili_prediction_log_score_diffs_long) +
    theme_bw() +
    theme(axis.text.x=element_text(angle = -90, hjust = 0))
@


<<FluDataPredictionsPlotViolinLogScoreDifferenceZoomedIn, fig.height = 8, echo = FALSE>>=
ggplot() +
    geom_violin(aes(x = factor(model), y = log_score_difference), data = ili_prediction_log_score_diffs_long) +
    theme_bw() +
    ylim(c(-6, 6)) +
    theme(axis.text.x=element_text(angle = -90, hjust = 0))
@

<<FluDataPredictionsPlotBoxplotLogScoreDifferenceZoomedIn, fig.height = 8, echo = FALSE>>=
ggplot() +
    geom_boxplot(aes(x = factor(model), y = log_score_difference), data = ili_prediction_log_score_diffs_long) +
    theme_bw() +
    ylim(c(-6, 6)) +
    theme(axis.text.x=element_text(angle = -90, hjust = 0))
@


<<FluDataPredictionsPlotStripLogScoreDifference, fig.height = 9, echo = FALSE>>=
ggplot() +
    geom_point(aes(x = factor(model), y = log_score_difference), size = 0.1, position = position_jitter(w = 0.2, h = 0), alpha = 0.01, data = ili_prediction_log_score_diffs_long) +
    theme_bw() +
    ylim(c(-6, 6)) +
    theme(axis.text.x=element_text(angle = -90, hjust = 0))
@


<<FluDataPredictionsPlotViolinLogScoreDifferencePeakSeasonOnly, echo = FALSE>>=
peak_season_test_inds_in_ili_national <- c(
    693:704, # 2010/2011 season, starting Jan 2011
    744:755, # 2011/2012 season
    791:808, # 2012/2013 season
    844:857, # 2013/2014 season
    895:901  # 2014/2015 season, ending end of Dec 2014
)
peak_season_test_times <- ili_national$time[peak_season_test_inds_in_ili_national]



ili_prediction_log_score_diffs_wide <- ili_prediction_results %>%
    select(full_model_descriptor, prediction_time, prediction_horizon, log_score) %>%
    spread(full_model_descriptor, log_score)

ili_prediction_log_score_diffs_wide[, unique(ili_prediction_results$full_model_descriptor)] <-
    ili_prediction_log_score_diffs_wide[, unique(ili_prediction_results$full_model_descriptor)] -
    ili_prediction_log_score_diffs_wide[, "SARIMA-seasonal_lag_NA-differencing_NA-periodic_NA-bw_NA"]
#    ili_prediction_log_score_diffs_wide[, "SARIMA-seasonal_lag_NA-filtering_NA-differencing_NA-periodic_NA-bw_NA"]

ili_prediction_log_score_diffs_long <- ili_prediction_log_score_diffs_wide %>%
    gather_("model", "log_score_difference", unique(ili_prediction_results$full_model_descriptor))

ggplot() +
    geom_violin(aes(x = factor(model), y = log_score_difference),
        data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$prediction_time %in% peak_season_test_times, ]) +
    theme_bw() +
    theme(axis.text.x=element_text(angle = -60, hjust = 0))
@



<<FluDataPredictionsPlotViolinLogScoreDifferenceOnlyModelsWithoutFiltering, echo = FALSE>>=
models_used <- c("kcde-filtering_FALSE-periodic_FALSE-bw_diagonal",
    "kcde-filtering_FALSE-periodic_FALSE-bw_full",
    "kcde-filtering_FALSE-periodic_TRUE-bw_diagonal",
    "kcde-filtering_FALSE-periodic_TRUE-bw_full")

central_stat_log_score_diff_by_model <- ili_prediction_log_score_diffs_long %>%
    group_by(model) %>%
    summarize(median = median(log_score_difference),
        mean = mean(log_score_difference)) %>%
    gather_("statistic", "value", c("median", "mean"))

ggplot() +
    geom_violin(aes(x = factor(model), y = log_score_difference),
        data = ili_prediction_log_score_diffs[ili_prediction_log_score_diffs$model %in% models_used, ]) +
    geom_hline(aes(yintercept = 0), colour = "red") +
    geom_point(aes(x = factor(model), y = value, colour = statistic),
        data = central_stat_log_score_diff_by_model[central_stat_log_score_diff_by_model$model %in% models_used, ]) +
    theme_bw() +
    theme(axis.text.x=element_text(angle = -60, hjust = 0))
@


%<<FluDataPredictionsPlotViolinLogScoreDifferenceByHorizon, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%
%
%median_log_score_diff_by_model_and_horizon <- ili_prediction_log_score_diffs_long %>%
%    group_by(model, prediction_horizon) %>%
%    summarize(median = median(log_score_difference))
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_violin(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    geom_point(aes(x = factor(prediction_horizon), y = median), colour = "blue", data = median_log_score_diff_by_model_and_horizon[median_log_score_diff_by_model_and_horizon$model %in% models_used, ]) +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@


%<<FluDataPredictionsPlotLineLogScoreDifferenceByPredictionTimeAndHorizon, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%
%phs_used <- c(1, 6, 13, 26, 39, 52)
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used & ili_prediction_log_score_diffs_long$prediction_horizon %in% phs_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_point(aes(x = prediction_time, y = log_score_difference, colour = factor(prediction_horizon), shape = factor(prediction_horizon))) +
%    geom_line(aes(x = prediction_time, y = log_score_difference, colour = factor(prediction_horizon))) +
%    geom_hline(aes(yintercept = 0), colour = "black") +
%#    geom_point(aes(x = factor(prediction_horizon), y = median), colour = "blue", data = median_log_score_diff_by_model_and_horizon[median_log_score_diff_by_model_and_horizon$model %in% models_used, ]) +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw()# +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%<<FluDataPredictionsPlotBoxplotLogScoreDifferenceByHorizonOnlyModelsWithDifferencing, fig.height = 9, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full",
%    "kcde-seasonal_lag_0-differencing_TRUE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_1-differencing_TRUE-periodic_FALSE-bw_diagonal",
%    "kcde-seasonal_lag_1-differencing_TRUE-periodic_TRUE-bw_diagonal")
%
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_boxplot(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%%<<FluDataPredictionsPlotBoxplotScoreRatioByHorizonOnlyModelsWithDifferencing, fig.height = 9, echo = FALSE>>=
%%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%%#    facet_wrap( ~ model, ncol = 1) +
%%#    theme_bw() +
%%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%%
%%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full")
%%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full",
%%    "kcde-seasonal_lag_0-differencing_TRUE-periodic_TRUE-bw_full",
%%    "kcde-seasonal_lag_1-differencing_TRUE-periodic_FALSE-bw_diagonal",
%%    "kcde-seasonal_lag_1-differencing_TRUE-periodic_TRUE-bw_diagonal")
%%
%%
%%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%%    geom_boxplot(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%%    geom_hline(aes(yintercept = 0), colour = "red") +
%%    facet_wrap( ~ model, ncol = 1) +
%%    theme_bw() +
%%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%%@
%
%
%<<FluDataPredictionsPlotBoxplotLogScoreDifferenceByHorizonOnlyModelsWithoutDifferencing, fig.height = 9, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full")
%
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_boxplot(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%
%<<FluDataPredictionsPlotBoxplotScoreRatioByHorizonOnlyModelsWithoutDifferencing, fig.height = 9, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-FALSE-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_TRUE-periodic_FALSE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_FALSE-bw_full",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full")
%
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_boxplot(aes(x = factor(prediction_horizon), y = exp(log_score_difference))) +
%    geom_hline(aes(yintercept = 1), colour = "red") +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%<<FluDataPredictionsPlotViolinLogScoreDifferenceByHorizonPeakSeasonOnly, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%
%median_log_score_diff_by_model_and_horizon <- ili_prediction_log_score_diffs_long %>%
%    group_by(model, prediction_horizon) %>%
%    summarize(median = median(log_score_difference))
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used & ili_prediction_log_score_diffs_long$prediction_time %in% peak_season_test_times, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_violin(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    geom_point(aes(x = factor(prediction_horizon), y = median), colour = "blue", data = median_log_score_diff_by_model_and_horizon[median_log_score_diff_by_model_and_horizon$model %in% models_used, ]) +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%<<FluDataPredictionsPlotStripLogScoreDifferenceByHorizonPeakSeasonOnly, echo = FALSE>>=
%#ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% unique(ili_prediction_results$full_model_descriptor)[2:5], ]) +
%##    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%#    geom_point(aes(x = prediction_horizon, y = log_score_difference)) +
%#    facet_wrap( ~ model, ncol = 1) +
%#    theme_bw() +
%#    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full")
%models_used <- c("kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%
%models_used <- c("kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_1-differencing_FALSE-periodic_TRUE-bw_diagonal",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_full",
%    "kcde-seasonal_lag_0-differencing_FALSE-periodic_TRUE-bw_diagonal")
%
%median_log_score_diff_by_model_and_horizon <- ili_prediction_log_score_diffs_long %>%
%    group_by(model, prediction_horizon) %>%
%    summarize(median = median(log_score_difference))
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used & ili_prediction_log_score_diffs_long$prediction_time %in% peak_season_test_times, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%    geom_point(aes(x = factor(prediction_horizon), y = log_score_difference),
%        position = position_jitter(width = 0.1, height = 0)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    geom_point(aes(x = factor(prediction_horizon), y = median), colour = "blue", data = median_log_score_diff_by_model_and_horizon[median_log_score_diff_by_model_and_horizon$model %in% models_used, ]) +
%    facet_wrap( ~ model, ncol = 1) +
%    theme_bw() +
%    theme(axis.text.x=element_text(angle = -60, hjust = 0))
%@
%
%
%<<FluDataResultsPredictionHorizonSplinesPlot, fig.height = 9, echo = FALSE>>=
%library(splines)
%
%prediction_horizon_spline_basis_for_plot <- bs(1:52, df = 26, intercept = TRUE)
%prediction_horizon_spline_basis_plot_df <- prediction_horizon_spline_basis_for_plot %>%
%    as.data.frame() %>%
%    mutate(prediction_horizon = 1:52) %>%
%    gather_("spline", "value", as.character(1:26))
%
%ggplot(prediction_horizon_spline_basis_plot_df) +
%    geom_line(aes(x = prediction_horizon, y = value, colour = spline)) +
%    theme_bw()
%@


%<<FluDataResultsModelIndepBoxplot1, fig.height = 9, echo = FALSE>>=
%ili_prediction_log_score_diffs_long <- ili_prediction_log_score_diffs_long %>%
%    filter(model != "SARIMA-seasonal_lag_NA-differencing_NA-periodic_NA-bw_NA")
%
%ili_prediction_log_score_diffs_long$model_indicator <- as.integer(as.factor(ili_prediction_log_score_diffs_long$model))
%
%ili_results_fit_samples <- readRDS(
%    file = "/media/evan/data/Reich/infectious-disease-prediction-with-kcde/inst/results/ili_national/analysis-results/influenza-results-model-samples-spline-indep-fit-chains_2-iter_1000.rds")
%
%N <- nrow(ili_prediction_log_score_diffs_long) 
%M <- 16
%B_spline <- 26
%B <- B_spline + 1
%
%
%## Make boxplot by prediction horizon for one model with corresponding spline fits superimposed
%plots <- lapply(seq_len(16), function(models_used_inds) {
%#models_used_inds <- 1L
%        models_used_inds_in_log_score_diffs_long <- which(ili_prediction_log_score_diffs_long$model_indicator %in% models_used_inds)
%        models_used <- unique(ili_prediction_log_score_diffs_long$model[models_used_inds_in_log_score_diffs_long])
%        
%        
%        beta_inds <- seq_len(B) + (models_used_inds - 1) * B
%        spline_fits <-
%            data.frame(
%                prediction_horizon = seq_len(52),
%                spline_fit = cbind(
%                    matrix(1, nrow = 52),
%                    bs(seq_len(52),
%                        df = B_spline,
%                        intercept = TRUE)
%                ) %*% t(as.matrix(ili_results_fit_samples[, paste0("beta[", beta_inds, "]")]))
%            ) %>%
%            gather_("spline_fit", "fit_val", paste0("spline_fit.", seq_len(1000)))
%        
%        p <- ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]) +
%#    geom_violin(aes(x = prediction_horizon, y = log_score_difference)) +
%            geom_boxplot(aes(x = factor(prediction_horizon), y = log_score_difference)) +
%            geom_line(aes(x = factor(prediction_horizon), y = fit_val, group = spline_fit), alpha = 0.01, data = spline_fits) +
%            geom_hline(aes(yintercept = 0), colour = "red") +
%            facet_wrap( ~ model, ncol = 1) +
%            theme_bw() +
%            theme(axis.text.x=element_text(angle = -60, hjust = 0))
%        return(p)
%    })
%
%print(plots[[1]])
%@
%
%<<FluDataResultsModelIndepBoxplot2, fig.height = 9, echo = FALSE>>=
%print(plots[[2]])
%@
%
%<<FluDataResultsModelIndepBoxplot3, fig.height = 9, echo = FALSE>>=
%print(plots[[3]])
%@
%
%<<FluDataResultsModelIndepBoxplot4, fig.height = 9, echo = FALSE>>=
%print(plots[[4]])
%@
%
%<<FluDataResultsModelIndepBoxplot5, fig.height = 9, echo = FALSE>>=
%print(plots[[5]])
%@
%
%<<FluDataResultsModelIndepBoxplot6, fig.height = 9, echo = FALSE>>=
%print(plots[[6]])
%@
%
%<<FluDataResultsModelIndepBoxplot7, fig.height = 9, echo = FALSE>>=
%print(plots[[7]])
%@
%
%<<FluDataResultsModelIndepBoxplot8, fig.height = 9, echo = FALSE>>=
%print(plots[[8]])
%@
%
%<<FluDataResultsModelIndepBoxplot9, fig.height = 9, echo = FALSE>>=
%print(plots[[9]])
%@
%
%<<FluDataResultsModelIndepBoxplot10, fig.height = 9, echo = FALSE>>=
%print(plots[[10]])
%@
%
%<<FluDataResultsModelIndepBoxplot11, fig.height = 9, echo = FALSE>>=
%print(plots[[11]])
%@
%
%<<FluDataResultsModelIndepBoxplot12, fig.height = 9, echo = FALSE>>=
%print(plots[[12]])
%@
%
%<<FluDataResultsModelIndepBoxplot13, fig.height = 9, echo = FALSE>>=
%print(plots[[13]])
%@
%
%<<FluDataResultsModelIndepBoxplot14, fig.height = 9, echo = FALSE>>=
%print(plots[[14]])
%@
%
%<<FluDataResultsModelIndepBoxplot15, fig.height = 9, echo = FALSE>>=
%print(plots[[15]])
%@
%
%<<FluDataResultsModelIndepBoxplot16, fig.height = 9, echo = FALSE>>=
%print(plots[[16]])
%@
%
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime1, echo = FALSE>>=
%## Get median within model and prediction horizon
%ili_prediction_median_log_score_diffs_by_model_and_ph <-
%    ili_prediction_log_score_diffs_long %>%
%    group_by(model, prediction_horizon) %>%
%    summarize(median_by_model_and_ph = median(log_score_difference))
%
%ili_prediction_log_score_diffs_long <- 
%    ili_prediction_log_score_diffs_long %>%
%    left_join(ili_prediction_median_log_score_diffs_by_model_and_ph,
%        by = c("model", "prediction_horizon")) %>%
%    mutate(log_score_difference_residual_from_median = log_score_difference - median_by_model_and_ph)
%
%#temp <- ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model == unique(ili_prediction_log_score_diffs_long$model)[4], ]
%#temp <- temp[order(temp$prediction_horizon), ]
%
%## For each model, ...
%plots <- lapply(seq_len(16), function(models_used_inds) {
%        ## 
%        models_used_inds_in_log_score_diffs_long <- which(ili_prediction_log_score_diffs_long$model_indicator %in% models_used_inds)
%        models_used <- unique(ili_prediction_log_score_diffs_long$model[models_used_inds_in_log_score_diffs_long])
%        
%        reduced_ili_prediction_log_score_diffs_long <-
%            ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]
%        ## For each time point, get acf wrt prediction horizon
%        
%        time_names <- paste0("time_",
%            seq_along(unique(reduced_ili_prediction_log_score_diffs_long$prediction_time))
%        )
%        plot_data <- sapply(
%            unique(reduced_ili_prediction_log_score_diffs_long$prediction_time),
%            function(prediction_time) {
%                temp <- reduced_ili_prediction_log_score_diffs_long[
%                    reduced_ili_prediction_log_score_diffs_long$prediction_time == prediction_time, ]
%                temp <- temp[order(temp$prediction_horizon), ]
%                acf(temp$log_score_difference_residual_from_median, plot = FALSE)$acf
%            }) %>%
%            as.data.frame() %>%
%            `colnames<-`(time_names) %>%
%            mutate(lag_in_horizon_time_fixed = seq(from = 0, to = 17)) %>%
%            gather_("time", "residual_acf", time_names)
%        
%        acf_null_limits <- qnorm((1 + 0.95)/2)/sqrt(52)
%        
%        p <- ggplot(plot_data) +
%            geom_point(aes(x = lag_in_horizon_time_fixed, y = residual_acf), colour = "grey") +
%            geom_line(aes(x = lag_in_horizon_time_fixed, y = residual_acf, group = time), colour = "grey") +
%            geom_hline(yintercept = 0) +
%            geom_hline(yintercept = acf_null_limits, colour = "blue", linetype = 2) +
%            geom_hline(yintercept = -acf_null_limits, colour = "blue", linetype = 2) +
%            ggtitle(paste0(models_used, "\nPrediction Time Fixed")) +
%            theme_bw()
%        
%        
%        return(p)
%    })
%
%print(plots[[1]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime2, fig.height = 9, echo = FALSE>>=
%print(plots[[2]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime3, fig.height = 9, echo = FALSE>>=
%print(plots[[3]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime4, fig.height = 9, echo = FALSE>>=
%print(plots[[4]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime5, fig.height = 9, echo = FALSE>>=
%print(plots[[5]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime6, fig.height = 9, echo = FALSE>>=
%print(plots[[6]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime7, fig.height = 9, echo = FALSE>>=
%print(plots[[7]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime8, fig.height = 9, echo = FALSE>>=
%print(plots[[8]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime9, fig.height = 9, echo = FALSE>>=
%print(plots[[9]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime10, fig.height = 9, echo = FALSE>>=
%print(plots[[10]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime11, fig.height = 9, echo = FALSE>>=
%print(plots[[11]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime12, fig.height = 9, echo = FALSE>>=
%print(plots[[12]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime13, fig.height = 9, echo = FALSE>>=
%print(plots[[13]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime14, fig.height = 9, echo = FALSE>>=
%print(plots[[14]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime15, fig.height = 9, echo = FALSE>>=
%print(plots[[15]])
%@
%
%<<FluDataResultsResidualsACFByPHWithinModelAndTime16, fig.height = 9, echo = FALSE>>=
%print(plots[[16]])
%@
%
%
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH1, echo = FALSE>>=
%## Get median within model and prediction horizon
%
%#temp <- ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model == unique(ili_prediction_log_score_diffs_long$model)[4], ]
%#temp <- temp[order(temp$prediction_horizon), ]
%
%## For each model, ...
%plots <- lapply(seq_len(16), function(models_used_inds) {
%        ## 
%        models_used_inds_in_log_score_diffs_long <- which(ili_prediction_log_score_diffs_long$model_indicator %in% models_used_inds)
%        models_used <- unique(ili_prediction_log_score_diffs_long$model[models_used_inds_in_log_score_diffs_long])
%        
%        reduced_ili_prediction_log_score_diffs_long <-
%            ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used, ]
%        ## For each time point, get acf wrt prediction horizon
%        
%        ph_names <- paste0("ph_", seq_len(52))
%        plot_data <- sapply(
%            seq_len(52),
%            function(prediction_horizon) {
%                temp <- reduced_ili_prediction_log_score_diffs_long[
%                    reduced_ili_prediction_log_score_diffs_long$prediction_horizon == prediction_horizon, ]
%                temp <- temp[order(temp$prediction_time), ]
%                acf(temp$log_score_difference_residual_from_median, plot = FALSE)$acf
%            }) %>%
%            as.data.frame() %>%
%            `colnames<-`(ph_names)
%        plot_data$lag_in_time_horizon_fixed <- seq(from = 0, to = nrow(plot_data) - 1)
%        plot_data <- gather_(plot_data, "prediction_horizon", "residual_acf", time_names)
%        
%        acf_null_limits <- qnorm((1 + 0.95)/2)/sqrt(length(unique(reduced_ili_prediction_log_score_diffs_long$prediction_time)))
%        
%        p <- ggplot(plot_data) +
%            geom_point(aes(x = lag_in_time_horizon_fixed, y = residual_acf), colour = "grey") +
%            geom_line(aes(x = lag_in_time_horizon_fixed, y = residual_acf, group = prediction_horizon), colour = "grey") +
%            geom_hline(yintercept = 0) +
%            geom_hline(yintercept = acf_null_limits, colour = "blue", linetype = 2) +
%            geom_hline(yintercept = -acf_null_limits, colour = "blue", linetype = 2) +
%            ggtitle(paste0(models_used, "\nPrediction Horizon Fixed")) +
%            theme_bw()
%        
%        
%        return(p)
%    })
%
%print(plots[[1]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH2, fig.height = 9, echo = FALSE>>=
%print(plots[[2]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH3, fig.height = 9, echo = FALSE>>=
%print(plots[[3]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH4, fig.height = 9, echo = FALSE>>=
%print(plots[[4]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH5, fig.height = 9, echo = FALSE>>=
%print(plots[[5]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH6, fig.height = 9, echo = FALSE>>=
%print(plots[[6]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH7, fig.height = 9, echo = FALSE>>=
%print(plots[[7]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH8, fig.height = 9, echo = FALSE>>=
%print(plots[[8]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH9, fig.height = 9, echo = FALSE>>=
%print(plots[[9]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH10, fig.height = 9, echo = FALSE>>=
%print(plots[[10]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH11, fig.height = 9, echo = FALSE>>=
%print(plots[[11]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH12, fig.height = 9, echo = FALSE>>=
%print(plots[[12]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH13, fig.height = 9, echo = FALSE>>=
%print(plots[[13]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH14, fig.height = 9, echo = FALSE>>=
%print(plots[[14]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH15, fig.height = 9, echo = FALSE>>=
%print(plots[[15]])
%@
%
%<<FluDataResultsResidualsACFByTimeWithinModelAndPH16, fig.height = 9, echo = FALSE>>=
%print(plots[[16]])
%@

<<FluDataResultsEmpiricalContrastsSeasonalLag, fig.height = 9, echo = FALSE>>=
ili_prediction_log_score_diffs_long <- ili_prediction_log_score_diffs_long %>%
    mutate(
        seasonal_lag = grepl("seasonal_lag_1", model),
        differencing = grepl("differencing_TRUE", model),
        periodic = grepl("periodic_TRUE", model),
        bw_full = grepl("bw_full", model)
    )

ili_contrast_seasonal_lag <- ili_prediction_log_score_diffs_long %>%
    select_("prediction_time", "prediction_horizon", "log_score_difference",
        "seasonal_lag", "differencing", "periodic", "bw_full") %>%
    spread_("seasonal_lag",
        "log_score_difference") %>%
    mutate(
        contrast_value = `TRUE` - `FALSE`,
        fixed_values = paste0("differencing_", differencing, "-periodic_", periodic, "-bw_full_", bw_full))

ggplot(ili_contrast_seasonal_lag) +
    geom_boxplot(aes(x = factor(prediction_horizon), y = contrast_value)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Seasonal Lag to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsMedianSeasonalLag, fig.height = 9, echo = FALSE>>=
ili_contrast_seasonal_lag_medians <- ili_contrast_seasonal_lag %>%
    group_by(prediction_horizon, fixed_values) %>%
    summarize(median_contrast = median(contrast_value))

ggplot(ili_contrast_seasonal_lag_medians) +
    geom_point(aes(x = factor(prediction_horizon), y = median_contrast)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Seasonal Lag to Model") +
    theme_bw()
@


<<FluDataResultsEmpiricalContrastsDifferencing, fig.height = 9, echo = FALSE>>=
ili_contrast_differencing <- ili_prediction_log_score_diffs_long %>%
    select_("prediction_time", "prediction_horizon", "log_score_difference",
        "seasonal_lag", "differencing", "periodic", "bw_full") %>%
    spread_("differencing",
        "log_score_difference") %>%
    mutate(
        contrast_value = `TRUE` - `FALSE`,
        fixed_values = paste0("seasonal_lag_", seasonal_lag, "-periodic_", periodic, "-bw_full_", bw_full))

ggplot(ili_contrast_differencing) +
    geom_boxplot(aes(x = factor(prediction_horizon), y = contrast_value)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Seasonal Differencing to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsMedianDifferencing, fig.height = 9, echo = FALSE>>=
ili_contrast_differencing_medians <- ili_contrast_differencing %>%
    group_by(prediction_horizon, fixed_values) %>%
    summarize(median_contrast = median(contrast_value))

ggplot(ili_contrast_differencing_medians) +
    geom_point(aes(x = factor(prediction_horizon), y = median_contrast)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Seasonal Differencing to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsPeriodic, fig.height = 9, echo = FALSE>>=
ili_contrast_periodic <- ili_prediction_log_score_diffs_long %>%
    select_("prediction_time", "prediction_horizon", "log_score_difference",
        "seasonal_lag", "differencing", "periodic", "bw_full") %>%
    spread_("periodic",
        "log_score_difference") %>%
    mutate(
        contrast_value = `TRUE` - `FALSE`,
        fixed_values = paste0("seasonal_lag_", seasonal_lag, "-differencing_", differencing, "-bw_full_", bw_full))

ggplot(ili_contrast_periodic) +
    geom_boxplot(aes(x = factor(prediction_horizon), y = contrast_value)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Periodic Kernel to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsMedianPeriodic, fig.height = 9, echo = FALSE>>=
ili_contrast_periodic_medians <- ili_contrast_periodic %>%
    group_by(prediction_horizon, fixed_values) %>%
    summarize(median_contrast = median(contrast_value))

ggplot(ili_contrast_periodic_medians) +
    geom_point(aes(x = factor(prediction_horizon), y = median_contrast)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Periodic Kernel to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsBWFull, fig.height = 9, echo = FALSE>>=
ili_contrast_bw_full <- ili_prediction_log_score_diffs_long %>%
    select_("prediction_time", "prediction_horizon", "log_score_difference",
        "seasonal_lag", "differencing", "periodic", "bw_full") %>%
    spread_("bw_full",
        "log_score_difference") %>%
    mutate(
        contrast_value = `TRUE` - `FALSE`,
        fixed_values = paste0("seasonal_lag_", seasonal_lag, "-differencing_", differencing, "-periodic_", periodic))

ggplot(ili_contrast_bw_full) +
    geom_boxplot(aes(x = factor(prediction_horizon), y = contrast_value)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Full BW Parameterization to Model") +
    theme_bw()
@

<<FluDataResultsEmpiricalContrastsMedianBWFull, fig.height = 9, echo = FALSE>>=
ili_contrast_bw_full_medians <- ili_contrast_bw_full %>%
    group_by(prediction_horizon, fixed_values) %>%
    summarize(median_contrast = median(contrast_value))

ggplot(ili_contrast_bw_full_medians) +
    geom_point(aes(x = factor(prediction_horizon), y = median_contrast)) +
    geom_hline(yintercept = 0, colour = "red") +
    facet_wrap( ~ fixed_values, ncol = 1) +
    ggtitle("Effect of Adding Full BW Parameterization to Model") +
    theme_bw()
@


%<<FluDataResultsGAMM>>=
%## Outcome is y_{t, h, s, d, p, b}, where
%## t = week for which y_{t, h, s, d, p, b} is a prediction.
%##     Predictions are made each week for the 4 years in the test set.
%## h = prediction horizon.  The prediction is made from h weeks before t.
%##     For each target week, we make predictions for every horizon between 1 and 52 weeks.
%## s = seasonal lag included in model.  Either 0 or 1.
%## d = differencing used?  True/False
%## p = periodic kernel used?  True/False
%## b = bandwidth parameterization:  Diagonal or Full
%## 
%## Mean structure:
%##     E(y_{t, h, s, d, p, b}) = mu_{s, d, p, b} + spline(h)_{s, d, p, b}
%##     The spline term is in the prediction horizon, with a separate spline
%##     fit for each combination of s, d, p, and b
%## 
%## Covariance structure:
%##     We want autocorrelation in t.
%##     We may want correlation in nearby h?
%##     We want different variances for different s, d, p, b.
%## y_{t, h, s, d, p, b} = E(y_{t, h, s, d, p, b}) + alpha_ + epsilon_{t, h, s, d, p, b}
%## 
%##     Var(y_{t, h, s, d, p, b}) = blah
%##     Cov(y_{t, h, s, d, p, b}, y_{t, h, s, d, p, b}) = blah
%flu_data_results_gamm_fit <- gamm4(
%#    formula = log_score_difference ~ model + s(prediction_horizon, model, bs = "fs"), # the s term gives a separate smooth for each level of model
%    formula = log_score_difference ~ model + s(prediction_horizon, by = model), # the s term gives a separate smooth for each level of model
%    random = ,
%    data = ili_prediction_log_score_diffs_long
%)
%
%plot(flu_data_results_gamm_fit$gam,pages=1)
%summary(flu_data_results_gamm_fit$gam)
%@


%<<FluDataLogScoreDiffVsTimePlot, echo = FALSE>>=
%phs_used <- c(1, 6, 13, 26, 52)
%models_used <- c("kcde-filtering_FALSE-periodic_TRUE-bw_full")
%
%ggplot(data = ili_prediction_log_score_diffs_long[ili_prediction_log_score_diffs_long$model %in% models_used &
%                ili_prediction_log_score_diffs_long$prediction_horizon %in% phs_used, ]) +
%    geom_line(aes(x = prediction_time, y = log_score_difference)) +
%    geom_point(aes(x = prediction_time, y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    facet_wrap( ~ prediction_horizon, ncol = 1) +
%    ylim(c(-4, 4)) +
%    theme_bw()
%    
%@
%
%<<FluDataLogScoreDiffVsObsIncidencePlot, echo = FALSE>>=
%ili_prediction_log_score_diffs_long_with_obs_incidence <- ili_prediction_log_score_diffs_long %>%
%    left_join(ili_national, by = c("prediction_time" = "time"))
%
%ggplot(data = ili_prediction_log_score_diffs_long_with_obs_incidence[
%            ili_prediction_log_score_diffs_long_with_obs_incidence$model %in% models_used &
%                ili_prediction_log_score_diffs_long_with_obs_incidence$prediction_horizon %in% phs_used, ]) +
%    geom_line(aes(x = weighted_ili, y = log_score_difference)) +
%    geom_point(aes(x = weighted_ili, y = log_score_difference)) +
%    geom_hline(aes(yintercept = 0), colour = "red") +
%    facet_wrap( ~ prediction_horizon, ncol = 1) +
%    ylim(c(-4, 4)) +
%    theme_bw()
%@



<<ACFBySeasonInfluenza>>=
pit_inc_traj_acf_by_season <- rbind.fill(lapply(
        seq_len(11),
        function(season_row_ind) {
            temp <- acf(pit_incidence_trajectories[season_row_ind, ], plot = FALSE)
            return(data.frame(
                    season = rownames(pit_incidence_trajectories)[season_row_ind],
                    acf = temp$acf,
                    lag = temp$lag
                ))
        }
    ))

acf_null_limits <- qnorm((1 + 0.95)/2)/sqrt(max_prediction_horizon)

ggplot(pit_inc_traj_acf_by_season) +
    geom_point(aes(x = lag, y = acf), colour = "grey") +
    geom_line(aes(x = lag, y = acf, group = season), colour = "grey") +
    geom_hline(yintercept = 0) +
    geom_hline(yintercept = acf_null_limits, colour = "blue", linetype = 2) +
    geom_hline(yintercept = -acf_null_limits, colour = "blue", linetype = 2) +
    theme_bw()
@


<<ACFBySeasonVsFromCopulaSimInfluenza>>=
pit_inc_traj_acf_by_season <- rbind.fill(lapply(
        seq_len(11),
        function(season_row_ind) {
            temp <- acf(pit_incidence_trajectories[season_row_ind, ], plot = FALSE)
            return(data.frame(
                    season = rownames(pit_incidence_trajectories)[season_row_ind],
                    acf = temp$acf,
                    lag = temp$lag,
                    type = "observed",
                    stringsAsFactors = FALSE
                ))
        }
    ))

acf_null_limits <- qnorm((1 + 0.95)/2)/sqrt(max_prediction_horizon)


ggplot(pit_inc_traj_acf_by_season) +
    geom_point(aes(x = lag, y = acf), colour = "grey") +
    geom_line(aes(x = lag, y = acf, group = season), colour = "grey") +
    geom_hline(yintercept = 0) +
    geom_hline(yintercept = acf_null_limits, colour = "blue", linetype = 2) +
    geom_hline(yintercept = -acf_null_limits, colour = "blue", linetype = 2) +
    theme_bw()

n_sim <- 11L

clayton_copula_fit <- fitCopula(
    copula = claytonCopula(dim = max_prediction_horizon),
    data = pit_incidence_trajectories,
    method = "ml")
frank_copula_fit <- fitCopula(
    copula = frankCopula(dim = max_prediction_horizon),
    data = pit_incidence_trajectories,
    method = "ml")
t_copula_fit <- fitCopula(
    copula = tCopula(dim = max_prediction_horizon, df.fixed = TRUE),
    data = pit_incidence_trajectories,
    method = "ml")
ar1_normal_copula_fit <- fitCopula(
    copula = normalCopula(dim = max_prediction_horizon, dispstr = "ar1"),
    data = pit_incidence_trajectories,
    method = "ml")
toep_normal_copula_fit <- fitCopula(
    copula = normalCopula(dim = max_prediction_horizon, dispstr = "toep"),
    data = pit_incidence_trajectories,
    method = "ml")

sim_pit_seq_acf <- rbind.fill(lapply(
    c(frank_copula_fit, clayton_copula_fit, t_copula_fit, toep_normal_copula_fit),
    function(copula_fit) {
        rbind.fill(lapply(
            seq_len(n_sim),
            function(sim_ind) {
                predictive_copula <- copula_fit@copula
                ## Note that the variance estimate for parameters is low; at least we're accounting for some uncertainty though...
                orig_params <- predictive_copula@parameters
                predictive_copula@parameters <- rmvnorm(1, copula_fit@estimate, sigma = copula_fit@var.est)[1, ]
                random_params <- predictive_copula@parameters
                if(identical(class(predictive_copula)[1], "normalCopula")) {
                    ## randomly generated parameters above may not yield a positive definite correlation matrix; correct
                    while(min(eigen(getSigma(predictive_copula))$values) < 0.00001) {
                        predictive_copula@parameters <- copula:::makePosDef(getSigma(predictive_copula))[1, 1 + seq_along(predictive_copula@parameters)]
                    }
                }
                
                sim_sequence <- rCopula(1, predictive_copula)[1, ]
                
                temp <- acf(sim_sequence, plot = FALSE)
                return(data.frame(
                    sim_ind = sim_ind,
                    acf = temp$acf,
                    lag = temp$lag,
                    type = class(copula_fit@copula)[[1]],
                    stringsAsFactors = FALSE
                ))
            }
        ))
    }
))

pit_inc_traj_acf_by_season$sim_ind <- pit_inc_traj_acf_by_season$season
combined_acfs <- rbind.fill(pit_inc_traj_acf_by_season, sim_pit_seq_acf)

ggplot(combined_acfs) +
    geom_point(aes(x = lag, y = acf), colour = "grey") +
    geom_line(aes(x = lag, y = acf, group = sim_ind), colour = "grey") +
    geom_hline(yintercept = 0) +
    geom_hline(yintercept = acf_null_limits, colour = "blue", linetype = 2) +
    geom_hline(yintercept = -acf_null_limits, colour = "blue", linetype = 2) +
    facet_wrap(~type, ncol = 1) +
    theme_bw()
@


\section{Future Work}


Ensembles -- either ensembles of KCDE and/or include as a component in an
ensemble

Bayesianize?

\section{References}
\label{sec:References}

\begingroup
\renewcommand{\section}[2]{}
\bibliographystyle{plainnat}
\bibliography{kde-bib}
\endgroup

\end{document}